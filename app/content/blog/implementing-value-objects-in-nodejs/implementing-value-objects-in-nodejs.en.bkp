---
type: 'post'
title: 'Implementing Value Objects in Node.js'
description: 'A practical guide to implementing Value Objects in TypeScript and Node.js to create more robust and expressive domain models, inspired by Domain-Driven Design principles.'
tags: ['nodejs', 'typescript', 'ddd', 'architecture', 'value-object']
publishedAt: '2025-11-02'
---
## Introducción: La Obsesión por los Primitivos y la Integridad de los Datos

Cuando iniciamos el trabajo en arquitecturas guiadas por Domain-Driven Design (DDD), es natural que las propiedades de nuestras Entidades iniciales se definan utilizando tipos primitivos de JavaScript/TypeScript, tales como string, number, o Date. Esto, por sí mismo, no es un error conceptual.

Sin embargo, la dependencia exclusiva de tipos primitivos para representar conceptos cruciales del dominio conduce a un problema que Eric Evans denominó la "Obsesión por los Primitivos".

### El Costo de la Obsesión

Depender únicamente de primitivos tiene un alto costo arquitectónico y de desarrollo:

1. Pobreza en el Lenguaje Ubicuo (Ubiquitous Language): Si una propiedad se llama email: string, el código no expresa la verdadera intención del dominio. ¿Es un email de contacto? ¿Está validado? ¿Está normalizado? El lenguaje se vuelve ambiguo.

2. Validación Dispersa (Violación de DRY): La obsesión por los primitivos deja puertas abiertas a que las reglas de validación y de negocio se dispersen y descentralicen. Si el formato de un email se valida en el Controller, luego en el Application Service y nuevamente en el Domain Service, estamos violando el principio DRY (Don't Repeat Yourself). La lógica de negocio fundamental se diluye, volviéndose frágil y costosa de mantener.

### La Solución DDD: Value Objects (VOs)

En DDD, implementamos los Value Objects para combatir esta fragilidad.

Un Value Object es un patrón que busca encapsular la lógica para la validación, creación, y manipulación de un campo o un grupo de campos específicos. Al hacer esto, aseguramos una Garantía de Siempre Válido: cualquier instancia de un VO que exista en nuestro dominio es, por definición, un objeto válido y canónico.

El VO no solo define la estructura del dato, sino también las reglas de negocio que lo rigen. Si no se puede crear un EmailAddress válido, la ejecución debe fallar inmediatamente, forzando a la capa de la aplicación (que es donde la información es untrusted) a manejar el error.

## II. La Promesa del VO: Tres Pilares de la Integridad

Un Value Object solo es un VO si cumple con tres reglas fundamentales. Estas reglas son el contrato arquitectónico que garantiza la integridad de los datos en todo tu Dominio. Si un objeto no cumple con una de estas reglas, es probable que no sea un Value Object, sino una Entidad.

1. Inmutabilidad (Immutability): El Estado Congelado.

    Esta es quizás la regla más sencilla y más potente.  

    Una vez que un Value Object es creado, su estado no puede cambiar. Es inmutable.

    Si tienes un EmailAddress con el valor "<usuario@dominio.com>", no existe un método público para cambiarlo a "<nuevo@dominio.com>".

    Para "cambiar" un VO, debes destruirlo y crear uno nuevo.

    En el caso del objeto Money, si quieres sumarle $5, el método add(5) no modifica la instancia actual; retorna una nueva instancia de Money con el nuevo monto.

    ¿Por qué es crucial? La inmutabilidad elimina por completo los efectos secundarios (side-effects) inesperados. Si pasas un VO a un servicio, tienes la total certeza de que el servicio no lo modificará, garantizando la consistencia en hilos, transacciones y arquitecturas de microservicios.

2. Igualdad por Valor (Value Equality): Lo que Importa es el Contenido

    A diferencia de las Entidades (que se definen por una identidad única o ID), un Value Object se define por el valor de sus componentes. Su identidad conceptual es irrelevante.

    El Principio: Dos VOs son iguales si todas sus propiedades son iguales.

    - Si tienes un objeto Money A con {amount: 10, currency: USD} y un objeto Money B con {amount: 10, currency: USD}, son exactamente el mismo Value Object, aunque sean dos instancias diferentes en memoria.

    - Un ejemplo de la vida real: Un billete de $\$20$ es igual a cualquier otro billete de $\$20$. El valor es idéntico; su número de serie (su "ID") es irrelevante para su función.

    Esta regla requiere que implementemos una lógica robusta de equals() en nuestra clase base.

3. La Garantía de "Siempre Válido" (Self-Validation)

    Este es el pilar que combate directamente la "Obsesión por los Primitivos".

    El Value Object tiene la responsabilidad exclusiva de validar sus propias reglas de negocio y normalizar sus datos durante el proceso de creación.

    - Validación: ¿El EmailAddress cumple con el formato? ¿El DateRange tiene una fecha de inicio anterior a la fecha de fin?

    - Normalización: Si el input es " <USER@DOMAIN.COM> ", el VO lo convertirá internamente a su forma canónica (limpia y minúscula): "<user@domain.com>".

    Si la validación falla o la normalización es imposible, el VO debe impedir su propia creación, ya sea lanzando una excepción o devolviendo un objeto Result con el fallo. Esto asegura que solo objetos legales entren en nuestro Dominio.

## III. Construyendo la Fortaleza: La Clase Base Abstracta de TypeScript

La meta arquitectónica es simple: crear una clase abstracta ValueObject<T> que se encargue de la Igualdad por Valor de forma automática y que imponga el contrato de Inmutabilidad a todas las clases que la hereden.

A. La Clase Abstracta `ValueObject<T>`

Definimos una clase genérica que acepta un tipo T (las propiedades que definen el valor, como string para un Email o MoneyProps para Money).

```typescript
type EqualityComponent = string | number | boolean |  Date | null | undefined | ValueObject<any>;

export abstract class ValueObject<T> {

  protected abstract getEqualityComponents(): EqualityComponent[];

  public equals(other?: ValueObject<T>): boolean {
    if (other === null || other === undefined) {
      return false;
    }

    if (other.constructor !== this.constructor) {
      return false;
    }

    const componentsA = this.getEqualityComponents();
    const componentsB = other.getEqualityComponents();

    if (componentsA.length !== componentsB.length) {
      return false;
    }

    return componentsA.every((component, index) => {
      const otherComponent = componentsB[index];

      if (component === null || component === undefined || otherComponent === null || otherComponent === undefined) {
        return component === otherComponent;
      }

      if (component instanceof ValueObject && otherComponent instanceof ValueObject) {
        return component.equals(otherComponent);
      }

      return component === otherComponent;
    });
  }
}

```

B. El Secreto de la Inmutabilidad y la Extensibilidad

Este abstract base class logra dos cosas críticas:

  1. Imposición de Contrato: Al hacer getEqualityComponents() abstracto, forzamos a cada desarrollador que crea un nuevo VO (como ZipCode o PhoneNumber) a declarar explícitamente qué define su valor. No hay forma de olvidarlo.

  2. Igualdad Automática: El método equals() es la joya. Él hace todo el trabajo pesado, incluyendo la comparación recursiva para VOs anidados.

      - Si comparas dos objetos Money, el método equals sabe que el componente Currency es, a su vez, otro Value Object, y automáticamente llama a currency.equals() para garantizar una comparación profunda y correcta. ¡Menos código boilerplate para ti!

Este diseño es la piedra angular que permite la implementación limpia de los VOs, haciendo que el principio DRY sea inherentemente parte de tu arquitectura.

## IV Código en el Mundo Real: Poniendo VOs a Trabajar

En esta sección, ilustraremos cómo utilizar la clase base abstracta que creamos y cómo aplicamos el patrón de Fábrica Estática vs. Constructor Privado y la Composición de VOs.

A. Ejemplo 1: EmailAddress (El Bouncer de la Fábrica)

El EmailAddress es nuestro VO más fundamental. Su misión es simple: garantizar que el string interno es siempre un email válido y canónico.

El patrón clave aquí es:

1. static create() (El Portero): Recibe la data no confiable (untrusted) y realiza la validación y normalización.

2. private constructor() (El Guardián): Solo acepta la data limpia y final para establecer el estado inmutable.

```typescript

export class Email extends ValueObject<string> {

  public readonly value: string;

  private constructor(value: string) {
    super();
    this.value = value;
  }

  public static create(input: string): Email {

    if (!input) throw new Error("Email requires a value");

    const normalizedEmail = input.trim().toLowerCase();

    if (!Email.isValid(normalizedEmail)) {
      throw new Error("Invalid email address");
    }

    return new Email(normalizedEmail);
  }

  protected getEqualityComponents() {
    return [this.value];
  }

  private static isValid(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}

```

Este patrón asegura que, en el momento en que se ejecuta new Email(normalizedEmail), ya no hay necesidad de validación, cumpliendo con la Garantía de Siempre Válido.

B. Ejemplo 2: Money (Composición, Comportamiento e Inmutabilidad)

El VO Money es más complejo porque se compone de otros dos elementos (amount y currency), donde Currency debe ser, idealmente, otro Value Object.

```typescript

type MoneyProps = {
  readonly amount: number;
  readonly currency: Currency;
};

export class Money extends ValueObject<MoneyProps> {

  public readonly amount: number;

  public readonly currency: Currency;

  private constructor(props: MoneyProps) {
    super();
    this.amount = props.amount;
    this.currency = props.currency;
  }

  static create(inputProps: MoneyProps) {
    if (!inputProps) throw new Error("Money requires props");
    if (!inputProps.currency) throw new Error("Money requires currency");
    if (inputProps.amount < 0) throw new Error("Amount cannot be negative");

    //TODO add validation or normalization for Money values, ex. rounded two digits or something

    return new Money(inputProps);
  }

  public add(other: Money): Money {
    if (this.currency.code !== other.currency.code) {
      throw new Error("Cannot add money with different currencies");
    }
    return new Money({
      amount: this.amount + other.amount,
      currency: this.currency,
    });
  }

  public static zero(): Money;
  public static zero(props: { currency: Currency }): Money;

  public static zero(props?: { currency: Currency }): Money {
    const currency = props?.currency ?? Currency.None;
    return new Money({ currency, amount: 0 });
  }

  public isZero(): boolean {
    return this.amount === 0;
  }

  public isZeroInCurrency({ currency }: { currency: Currency }): boolean {
    return this.amount === 0 && this.currency.code === currency.code;
  }

  protected getEqualityComponents() {
    return [this.amount, this.currency]
  }

}

```

Lo Destacable del Money VO:

- Composición: Demuestra cómo se anidan VOs (la propiedad currency es de tipo Currency).

- Inmutabilidad Comportamental: El método add() siempre crea y devuelve un new Money(), jamás modifica su propio estado.

- Persistencia: Los decorators de MikroORM (@Embeddable, @Embedded) permiten que el VO sea guardado y cargado automáticamente por la capa de infraestructura sin lógica extra en el dominio.

## V Cierre Arquitectónico y Próximos Pasos

El uso de Value Objects no es un ejercicio académico; es una decisión de diseño pragmática que eleva el estándar de calidad de tu proyecto.

Impacto Arquitectónico y Persistencia en Azure

Al definir la integridad del dato dentro del VO, logramos varios beneficios a nivel de arquitectura empresarial:

1. Fiabilidad del Contrato: Los equipos que consumen los VOs (por ejemplo, al recibir un EmailAddress en un Azure Function o un API Controller) no necesitan revalidar el dato; simplemente lo usan con confianza.

2. Mantenimiento Centralizado: Si la regla de un Name cambia (ej. debe permitir caracteres Unicode), solo se modifica la lógica en un solo lugar: el método create() del VO, adhiriéndose estrictamente al principio DRY.

3. Persistencia Limpia: Mediante herramientas como MikroORM (como lo has demostrado), el Infrastructure Layer (base de datos, ORM) puede persistir los VOs directamente sin requerir que la Entidad se preocupe por cómo descomponer o reconstruir sus valores.

Los VOs son la base para construir modelos de Dominio que son mantenedores, fiables y testables a escala.

Conclusión: El Primer Paso hacia un Dominio Robusto
Hemos visto que el costo de la "Obsesión por los Primitivos" es la fragilidad del código. La solución es simple y poderosa: encapsular la validación y la lógica de valor en Value Objects inmutables.

La clave es recordar:

- Fábrica Estática para la validación de entrada (untrusted).

- Constructor Privado para la asignación de estado final (trusted).

- Inmutabilidad garantizada por readonly y métodos que retornan nuevas instancias.

- getEqualityComponents() para la igualdad por valor automática.

¡Felicidades! Has definido uno de los dos pilares fundamentales de cualquier sistema basado en DDD.
